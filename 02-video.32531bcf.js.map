{"mappings":"AAEA,IAAMA,YAAc,CAClB,CACEC,GAAI,IACJC,MAAQ,6BACUC,OAAT,oBACOC,IAAV,mDACNC,KAAO,wnBAQT,CACEJ,GAAI,IACJC,MAAQ,oCACsBC,OAArB,kBACKC,IAAR,mDACNC,KAAO,gmBAQT,CACEJ,GAAI,IACJC,MAAQ,sCACQC,OAAP,gBACGC,IAAN,mDACNC,KAAO,4hBASXC,aAAaC,QAAQ,QAASC,KAAKC,UAAUT,cAWF,IAArCU,QAAUC,SAASC,cAAc,OACjCC,SAAWF,SAASC,cAAc,OACxCF,QAAQI,UAAUC,IAAI,QACtBF,SAASC,UAAUC,IAAI,SAGwB,IAAzCC,QAAUL,SAASM,cAAc,SACvCD,QAAQE,OAAOR,QAASG,UAExB,IAAMX,MAAQS,SAASC,cAAc,MACrCV,MAAMiB,YAAc,UACpB,IAAMC,KAAOT,SAASC,cAAc,MAC9BS,OAASV,SAASC,cAAc,UAQc,SAA3CU,kBACP,IAEMC,EAFQf,KAAKgB,MAAMlB,aAAamB,QAAQ,UAEzBC,KAAI,SAAAC,G,IAAGC,EAAKD,EAALzB,MAAOD,EAAE0B,EAAF1B,GACjC,MAAO,iBAAgD4B,OAA/B5B,EAAG,+BAAkC4B,OAAND,EAAM,4EAC5DE,KAAK,IAEsCV,KAAzCW,UAAW,GAE2CX,KAAtDY,mBAAmB,aAAcT,GAEnBZ,SAASsB,iBAAiB,eAClCC,SAAQ,SAAAC,GACjBA,EAAGC,iBAAiB,QAASC,kBAGf1B,SAASsB,iBAAiB,WAClCC,SAAQ,SAAAC,GACdA,EAAGC,iBAAiB,QAASE,eAYL,SAAnBD,cAAcE,GACrB,IAAMC,EAAQhC,KAAKgB,MAAMlB,aAAamB,QAAQ,UACxCgB,EAASF,EAAEG,OAAOC,WAAWC,QAAQ3C,GAIrCsB,EAASsB,oBAFFL,EAAMM,MAAK,SAAAnB,G,OAAKA,EAAF1B,KAAgBwC,MAG3CM,QAAQC,IAAIzB,GACZV,SAASkB,UAAYR,EAI8B,SAA5CsB,oBAAoBlB,G,IAAEsB,EAAFtB,EAAEzB,MAAOC,EAATwB,EAASxB,OAAQC,EAAjBuB,EAAiBvB,IAAKC,EAAtBsB,EAAsBtB,KACjD,MAAO,cAEJwB,OADCoB,EAAM,cAECpB,OADR1B,EAAO,qBAEP0B,OADQzB,EAAI,YACPyB,OAALxB,EAAK,gBAcoC,SAArCiC,WAAWC,GAElB,IAAMC,EAAQhC,KAAKgB,MAAMlB,aAAamB,QAAQ,UAC1CgB,EAASF,EAAEG,OAAOC,WAAWC,QAAQ3C,GAErCiD,EAAgBV,EAAMW,QAAO,SAAAxB,G,OAAIA,EAAF1B,KAAawC,KAIbnC,aAAxBC,QAAQ,QAASC,KAAKC,UAAUyC,IAI7C5B,kBAjFAD,OAAOF,YAAc,MACrBT,QAAQQ,OAAOhB,MAAOkB,KAAMC,QA6BMC","sources":["src/js/02.js"],"sourcesContent":["//const { join } = require(\"lodash\");\n\nconst initialData = [\n  {\n    id: '1',\n    title: `Apple. Эволюция компьютера`,\n    author: `Владимир Невзоров`,\n    img: `https://bukva.ua/img/products/449/449532_200.jpg`,\n    plot: `Богато иллюстрированный хронологический справочник по истории компьютеров, в котором увлекательно \n    и в структурированном виде изложена информация о создании и развитии техники Apple на фоне истории \n    персональных компьютеров в целом.\n    В книге даны описания десятков наиболее значимых моделей устройств как Apple, так и других производителей, \n    сопровождающиеся большим количеством оригинальных студийных фотографий.\n    Книга предназначена для широкого круга читателей, интересующихся историей электроники. \n    Она также может послужить источником вдохновения для дизайнеров, маркетологов и предпринимателей.`,\n  },\n  {\n    id: '2',\n    title: `Как объяснить ребенку информатику`,\n    author: `Кэрол Вордерман`,\n    img: `https://bukva.ua/img/products/480/480030_200.jpg`,\n    plot: `Иллюстрированная энциклопедия в формате инфографики о технических, социальных и культурных аспектах \n    в информатике. Пошагово объясняет, как детям максимально эффективно использовать компьютеры и интернет-сервисы, \n    оставаясь в безопасности. \n    Книга рассказывает обо всем: от хранения данных до жизни в интернет-пространстве, \n    от программирования до компьютерных атак. О том, как компьютеры функционируют, о современном программном \n    обеспечении, устройстве Интернета и цифровом этикете. Все концепты - от хакера до биткоина - \n    объясняются наглядно с помощью иллюстраций и схем.`,\n  },\n  {\n    id: '3',\n    title: `Путь скрам-мастера. #ScrumMasterWay`,\n    author: `Зузана Шохова`,\n    img: `https://bukva.ua/img/products/480/480090_200.jpg`,\n    plot: `Эта книга поможет вам стать выдающимся скрам-мастером и добиться отличных результатов с вашей командой. \n    Она иллюстрированная и легкая для восприятия - вы сможете прочитать ее за выходные, а пользоваться полученными \n    знаниями будете в течение всей карьеры.\n    Основываясь на 15-летнем опыте, Зузана Шохова рассказывает, какие роли и обязанности есть у скрам-мастера, \n    как ему решать повседневные задачи, какие компетенции нужны, чтобы стать выдающимся скрам-мастером, \n    какими инструментами ему нужно пользоваться.`,\n  },\n];\n\nlocalStorage.setItem('books', JSON.stringify(initialData));\n// При перезагрузки страницы наш скрипт читается сверху вниз и инициализируется заново, он доходит до 44 строки и перезаписывает и\n// все равно есть там что т о или нет, вся логика начинается с нуля\n// Для примера мы хотим работать не с initialData хранилищем, а записать данные в localStorage что потом можно было add,remowe,edit их\n\n\n\n\n// * let PARSED_LOCAL_STORAGE = JSON.parse(localStorage.getItem('books'));\n\n// 1) Задача в руте (корне) создать 2 Дива и дбавить им классы\nconst leftDiv = document.createElement('div');\nconst rightDiv = document.createElement('div');\nleftDiv.classList.add('left');\nrightDiv.classList.add('right');\n\n//2) добавляем в root Но сначала надо получить ссылку на родителя\nconst rootDiv = document.querySelector('#root');\nrootDiv.append(leftDiv, rightDiv);\n\nconst title = document.createElement('h1');\ntitle.textContent = 'Library';\nconst list = document.createElement('ul');\nconst addBtn = document.createElement('button');\naddBtn.textContent = 'ADD';\nleftDiv.append(title, list, addBtn);\n\n// 3) при кликании на название книги на (р-шку) справа должна появляться развернутая информация\n// нужно создать слушателей для наших р -шек\n// чтоб удобно было обращаться к р-шке  вписываем ей класс class =\"book-title\" в шаблон\n\nfunction renderBooksList() {\n  const books = JSON.parse(localStorage.getItem('books'))\n  // Фу парсит данные из локальнюхранилища, пробегается по ним map-ом, на основании каждого из объекта в массиве созд.разметку\n  const markup = books.map(({ title, id }) => {\n    return `<li data-id ='${id}'><p class = \"book-title\">${title}</p><button>Edit</button><button class =\"delete\">Delete</button></li>`;\n  }).join(''); // преобразуем в строку .join('');\n// Сначала очищаем перед вставкой, чтоб не было задвоения\n  list.innerHTML =''\n  // добавляем разметку в наш список (list - пустой тег ul, который мы заапендили выше)\n  list.insertAdjacentHTML('afterbegin', markup);\n  // получаем ссылки на все р-шки(названия книг) и добавляем каждой из них слушателя, обработчик события click и колбек фу renderPreview\n  const bookTitles = document.querySelectorAll('.book-title');\n  bookTitles.forEach(el => {\n    el.addEventListener('click', renderPreview);\n  });\n\n  const delBtns = document.querySelectorAll('.delete');\n  delBtns.forEach(el => {\n    el.addEventListener('click', deleteBook);\n  });\n}\n\n// вызываем фу чтоб создался списочек книг\nrenderBooksList();\n\n// 4) чтоб отображать превьюшку нужной книги нужно ее идентифицировать и мы добавляем датаАтрибут data-id =''\n// Через e.target ищем р-шку, потом ее родителя (там где id) --  e.target.parentNode\n// и у этой li-шки через датаАтрибут dataset.id считываем id  (e.target.parentNode.dataset.id)\n\n// 5 в renderPreview нам нужно распарсить наш массив\nfunction renderPreview(e) {\n  const books = JSON.parse(localStorage.getItem('books'))\n  const bookId = e.target.parentNode.dataset.id;\n  // по полученному id-ку находим нашу книгу (с которой мы взаимодействуем кликая на p-шку в массиве\n  const book = books.find(({ id }) => id === bookId);\n//созд перем markup в котор записыв результ вызова фу createPreviewMarkup ( с нашей найденной книгой - book)\n  const markup = createPreviewMarkup(book)\n  console.log(markup);\n  rightDiv.innerHTML = markup;\n}\n\n// Фу принимает объект книги и возвращает разметку для Превьюшки\nfunction createPreviewMarkup({ title, author, img, plot }) {\n  return `<div>\n<h2>${title}</h2>\n<p>${author}</p>\n<img src ='${img}'/>\n<p>${plot}</p>\n</div>`;\n}\n\n// function findById(e){\n//   const bookId = e.target.parentNode.dataset.id;\n//   // по полученному id-ку находим нашу книгу (с которой мы взаимодействуем кликая на p-шку в массиве\n//   return PARSED_LOCAL_STORAGE.find(({ id }) => id === bookId);\n// }\n// findById(e);\n\n// Чтоб реализовать delete Добавляем в размутку на кнопку class =\"delete\" и в той же Фу renderBooksList и добавляем \n// каждой из них слушателя, обработчик события click и колбек фу\n\nfunction deleteBook(e){\n\n  const books = JSON.parse(localStorage.getItem('books'))\nconst bookId = e.target.parentNode.dataset.id;\n//чтоб удалить выбранный елемент мы используем метод который возвращает массив С (либо в нашем случае без) выбранным(и) элемен\nconst filteredArray = books.filter(({id}) => id!==bookId)\n\n\n// Теперь нам надо Перезаписать localStorage чтоб обновить\nlocalStorage.setItem('books', JSON.stringify(filteredArray));\n// И вызвать фу renderBooksList которая заново созд.разметку\n\n// *важно-вызав этой фу к старой разметке добавляет новую => в фу renderBooksList надо добавить сначала очистку list.innerHTML =''\nrenderBooksList()\n}"],"names":["initialData","id","title","author","img","plot","localStorage","setItem","JSON","stringify","leftDiv","document","createElement","rightDiv","classList","add","rootDiv","querySelector","append","textContent","list","addBtn","renderBooksList","markup","parse","getItem","map","param","title1","concat","join","innerHTML","insertAdjacentHTML","querySelectorAll","forEach","el","addEventListener","renderPreview","deleteBook","e","books","bookId","target","parentNode","dataset","createPreviewMarkup","find","console","log","title2","filteredArray","filter"],"version":3,"file":"02-video.32531bcf.js.map"}